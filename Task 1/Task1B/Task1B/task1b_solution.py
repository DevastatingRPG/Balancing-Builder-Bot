import math
import time

def sysCall_init():
    sim = require('sim')

    # do some initialization here
    # This function will be executed once when the simulation starts
    
    # Instead of using globals, you can do e.g.:
    # self.myVariable = 21000000
    
    ######## ADD YOUR CODE HERE #######
    # Hint: Initialize the scene objects which you will require
    #       Initialize algorithm related variables here
    
    ##################################
    self.body = sim.getObject('/body')
    self.left_motor = sim.getObject('/left_joint')
    self.right_motor = sim.getObject('/right_joint')

    # pitch PID
    self.pi_kp = 15
    self.pi_ki = 2
    self.pi_kd = 0

    # position PID
    self.p_kp = 100
    self.p_ki = 2
    self.p_kd = 0

    # prev errors
    self.prev_p = 0
    self.prev_pos = 0

    # curr state
    self.pitch = 0
    self.pos = 0
    
    # gains
    self.pitch_gain = 0
    self.pos_gain = 0

    # integral PID controllers
    self.p_integral = 0
    self.pos_integral = 0

    self.tame = 0

    self.dt = sim.getSimulationTimeStep()


def sysCall_actuation():
    # put your actuation code here
    # This function will be executed at each simulation time step

    ####### ADD YOUR CODE HERE ######
    # Hint: Use the error feedback and apply control algorithm here
    #       Provide the resulting actuation as input to the actuator joint
    
    # Example psuedo code:
    #   x1 = error_state_1; # Error in states w.r.t desired setpoint
    #   x2 = error_state_2;
    #   x3 = error_state_3;
    #   x4 = error_state_4;
    #   k = [gain_1 , gain_1, gain_3, gain_4];      # These gains will be generated by control algorithm. For ex: LQR, PID, etc.
    #   U = -k[1]*x1 +k[2]*x2 -k[3]*x3 +k[4]*x4;    # +/- Sign convention may differ according to implementation
    #   Set_joint_actuation(U);                     # Provide this calculated input to system's actuator

    #################################
    pitch_error = 0 - self.pitch
    # pos_error = self.target_pos - self.pos
    pos_error = 0 - self.pos
    # time = sim.getSimulationTime() 
    # if time - self.tame >= 0.1:
    print(f"sdf: {self.pos}")
    self.pitch_gain, self.p_integral = PID(self.pi_kp, self.pi_ki, self.pi_kd, pitch_error, self.prev_p, self.p_integral)
    self.pos_gain, self.pos_integral = PID(self.p_kp, self.p_ki, self.p_kd, pos_error, self.prev_pos, self.pos_integral)
    vel = self.pitch_gain - self.pos_gain
    left_motor_vel = vel * 10 + self.manual_rotate * self.manual_rotate_speed
    right_motor_vel = vel * 10 - self.manual_rotate * self.manual_rotate_speed

    print(f"pitch: {self.pitch_gain}, pos: {self.pos_gain}, vel: {vel}")
    sim.setJointTargetVelocity(self.left_motor, left_motor_vel)
    sim.setJointTargetVelocity(self.right_motor, right_motor_vel)

    self.prev_p = pitch_error
    self.prev_pos = pos_error
        # self.tame = time

def sysCall_sensing():
    # put your sensing code here
    # This function will be executed at each simulation time step
    
    ####### ADD YOUR CODE HERE ######
    # Hint: Take feedback here & do the error calculation
    
    #################################
    self.pos = sim.getObjectPosition(self.body, -1)[1]
    
    # Initialize errors and PID variables
    # eulerAngles = sim.getObjectOrientation(self.body)
    eulerAngles = sim.getObjectOrientation(self.body, -1)
    pitch, yaw, self.pitch = sim.alphaBetaGammaToYawPitchRoll(eulerAngles[0], eulerAngles[1], eulerAngles[2])
    print(f"pitch: {self.pitch}")

    yaw = eulerAngles[2]

    # Convert yaw (rotation) from radians to degrees
    yaw_deg = yaw * (180 / math.pi)
    print(f"Rotation angle (yaw): {yaw_deg:.2f} degrees")
# Convert radians to degrees)

def PID(kp, ki, kd, err, prev_err, integral):
    derivative = (err - prev_err)/0.5
    integral += err*0.5
    response = kp * err + ki * integral + kd * derivative
    return response, integral

def sysCall_cleanup():
    # do some clean-up here
    # This function will be executed when the simulation ends
    
    ####### ADD YOUR CODE HERE ######
    # Any cleanup (if required) to take the scene back to it's original state after simulation
    # It helps in case simulation fails in an unwanted state.
    #################################
    pass

# See the user manual or the available code snippets for additional callback functions and details