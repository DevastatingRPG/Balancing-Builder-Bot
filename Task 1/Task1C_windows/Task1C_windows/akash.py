import math
import time

def sysCall_init():
    sim = require('sim')

    # do some initialization here
    # This function will be executed once when the simulation starts
    
    # Instead of using globals, you can do e.g.:
    # self.myVariable = 21000000
    
    ######## ADD YOUR CODE HERE #######
    # Hint: Initialize the scene objects which you will require
    #       Initialize algorithm related variables here
    
    ##################################
    self.body = sim.getObject('/body')
    self.left_motor = sim.getObject('/left_joint')
    self.right_motor = sim.getObject('/right_joint')

    # pitch PID
    self.pi_kp = 15
    self.pi_ki = 2
    self.pi_kd = 0

    # position PID
    self.p_kp = 120
    self.p_ki = 2
    self.p_kd = 0

    # prev errors
    self.prev_p = 0
    self.prev_pos = 0

    # curr state
    self.pitch = 0
    self.pos = 0
    self.pos_error = 0
    
    # gains
    self.pitch_gain = 0
    self.pos_gain = 0

    # integral PID controllers
    self.p_integral = 0
    self.pos_integral = 0

    self.tame = 0

    self.target_pos = 0
    # Variable for keyboard control (rotation only)
    self.manual_rotate = 0
    self.manual_rotate_speed = 10  # Adjust this to control rotation speed

    self.dt = sim.getSimulationTimeStep()

    self.posi = 0
    self.pitch_error = 0

def sysCall_actuation():
    # put your actuation code here
    # This function will be executed at each simulation time step

    ####### ADD YOUR CODE HERE ######
    # Hint: Use the error feedback and apply control algorithm here
    #       Provide the resulting actuation as input to the actuator joint
    
    # Example psuedo code:
    #   x1 = error_state_1; # Error in states w.r.t desired setpoint
    #   x2 = error_state_2;
    #   x3 = error_state_3;
    #   x4 = error_state_4;
    #   k = [gain_1 , gain_1, gain_3, gain_4];      # These gains will be generated by control algorithm. For ex: LQR, PID, etc.
    #   U = -k[1]*x1 +k[2]*x2 -k[3]*x3 +k[4]*x4;    # +/- Sign convention may differ according to implementation
    #   Set_joint_actuation(U);                     # Provide this calculated input to system's actuator

    #################################
    self.pitch_error = 0 - self.pitch
    # pos_error = self.target_pos - self.pos
    # time = sim.getSimulationTime() 
    # if time - self.tame >= 0.1:
    # print(f"sdf: {self.pos}")
    print(f"pos_error: {self.pos_error}")
    self.pitch_gain, self.p_integral = PID(self.pi_kp, self.pi_ki, self.pi_kd, self.pitch_error, self.prev_p, self.p_integral)
    self.pos_gain, self.pos_integral = PID(self.p_kp, self.p_ki, self.p_kd, self.pos_error, self.prev_pos, self.pos_integral)

    vel = self.pitch_gain - self.pos_gain
    left_motor_vel = vel * 10 + self.manual_rotate * self.manual_rotate_speed
    right_motor_vel = vel * 10 - self.manual_rotate * self.manual_rotate_speed

    print(f"pitch_gain: {self.pitch_gain}, pos_gain: {self.pos_gain}, vel: {vel}")
    sim.setJointTargetVelocity(self.left_motor, left_motor_vel)
    sim.setJointTargetVelocity(self.right_motor, right_motor_vel)

    self.prev_p = self.pitch_error
    self.prev_pos = self.pos_error
        # self.tame = time

    # self.prev_pos = self.target_pos

def sysCall_sensing():
    # put your sensing code here
    # This function will be executed at each simulation time step
    
    ####### ADD YOUR CODE HERE ######
    # Hint: Take feedback here & do the error calculation
    
    #################################
    # self.pos = sim.getObjectPosition(self.body, -1)[0]

    # self.posi = sim.getObjectPosition(self.body, -1)
    # print(f"posi: {self.posi}")
    
    # Initialize errors and PID variables
    eulerAngles = sim.getObjectOrientation(self.body)
    roll, yaw, self.pitch = sim.alphaBetaGammaToYawPitchRoll(eulerAngles[0], eulerAngles[1], eulerAngles[2])
    print(f"eul0: {eulerAngles[0]}, eul1: {eulerAngles[1]}, eul2: {eulerAngles[2]}")
    print(f"pitch: {self.pitch}\n")


    pitch = eulerAngles[2]
    deg = pitch * (180 / math.pi)
    print(f"Rotation angle (pitch): {deg:.2f} degrees")

    if -45 <= deg <= 45:
        self.pos = sim.getObjectPosition(self.body, -1)[1]
        self.pos_error = self.target_pos - self.pos
    elif -135 < deg < -45:
        self.pos = sim.getObjectPosition(self.body, -1)[0]
        self.pos_error = self.target_pos - self.pos
    elif -180 < deg <= -135 or 135 < deg <= 180:
        self.pos = sim.getObjectPosition(self.body, -1)[1]
        self.pos_error = self.target_pos + self.pos
    elif 45 < deg < 135:
        self.pos = sim.getObjectPosition(self.body, -1)[0]
        self.pos_error = self.target_pos + self.pos

    message, data, data2 = sim.getSimulatorMessage()
    if message == sim.message_keypress:
        if data[0] == 2007:  # forward up arrow
            self.target_pos += 0.007
        elif data[0] == 2008:  # backward down arrow
            self.target_pos -= 0.007
        elif (data[0] == 2009):  # left arrow key (rotate left)
            self.manual_rotate = 1  # Positive for left rotation
        elif (data[0] == 2010):  # right arrow key (rotate right)
            self.manual_rotate = -1  # Negative for right rotation
    else:
        self.manual_rotate = 0


def PID(kp, ki, kd, err, prev_err, integral):
    derivative = (err - prev_err)/0.5
    integral += err*0.5
    response = kp * err + ki * integral + kd * derivative
    return response, integral

def sysCall_cleanup():
    # do some clean-up here
    # This function will be executed when the simulation ends
    
    ####### ADD YOUR CODE HERE ######
    # Any cleanup (if required) to take the scene back to it's original state after simulation
    # It helps in case simulation fails in an unwanted state.
    #################################
    pass

# See the user manual or the available code snippets for additional callback functions and details