import math
import time

def sysCall_init():
    sim = require('sim')

    # do some initialization here
    # This function will be executed once when the simulation starts
    
    # Instead of using globals, you can do e.g.:
    # self.myVariable = 21000000
    
    ######## ADD YOUR CODE HERE #######
    # Hint: Initialize the scene objects which you will require
    #       Initialize algorithm related variables here
    
    ##################################
    self.body = sim.getObject('/body')
    self.left_motor = sim.getObject('/left_joint')
    self.right_motor = sim.getObject('/right_joint')

    # pitch PID
    self.pi_kp = 5
    self.pi_ki = 2
    self.pi_kd = 0

    # position PID
    self.p_kp = 50
    self.p_ki = 2
    self.p_kd = 0

    # prev errors
    self.prev_p = 0
    self.prev_pos = 0
    self.prev_vel = 0

    # curr state
    self.pitch = 0
    self.pos = 0
    
    # gains
    self.pitch_gain = 0
    self.pos_gain = 0

    # integral PID controllers
    self.p_integral = 0
    self.pos_integral = 0
    self.vel_integral = 0

    self.desired_vel = 0

    self.tame = 0

    self.target_pos = 0
    # Variable for keyboard control (rotation only)
    self.manual_rotate = 0
    self.manual_rotate_speed = 10  # Adjust this to control rotation speed

    self.dt = sim.getSimulationTimeStep()

def sysCall_actuation():
    # put your actuation code here
    # This function will be executed at each simulation time step

    ####### ADD YOUR CODE HERE ######
    # Hint: Use the error feedback and apply control algorithm here
    #       Provide the resulting actuation as input to the actuator joint
    
    # Example psuedo code:
    #   x1 = error_state_1; # Error in states w.r.t desired setpoint
    #   x2 = error_state_2;
    #   x3 = error_state_3;
    #   x4 = error_state_4;
    #   k = [gain_1 , gain_1, gain_3, gain_4];      # These gains will be generated by control algorithm. For ex: LQR, PID, etc.
    #   U = -k[1]*x1 +k[2]*x2 -k[3]*x3 +k[4]*x4;    # +/- Sign convention may differ according to implementation
    #   Set_joint_actuation(U);                     # Provide this calculated input to system's actuator

    #################################
    pitch_error = 0 - self.pitch
    pos_error = self.target_pos - self.pos
    # current_vel = sim.getJointTargetVelocity(self.left_motor)
    # vel_error = self.desired_vel - current_vel
    # time = sim.getSimulationTime() 
    # if time - self.tame >= 0.1:
    print(f"sdf: {self.pos}")
    self.pitch_gain, self.p_integral = PID(self.pi_kp, self.pi_ki, self.pi_kd, pitch_error, self.prev_p, self.p_integral)
    self.pos_gain, self.pos_integral = PID(self.p_kp, self.p_ki, self.p_kd, pos_error, self.prev_pos, self.pos_integral)
    # self.vel_gain, self.vel_integral = PID(self.p_kp, self.p_ki, self.p_kd, vel_error, self.prev_vel, self.vel_integral)

    vel = self.pitch_gain - self.pos_gain
    # vel = self.pitch_gain - self.vel_gain

    left_motor_vel = vel * 10 + self.manual_rotate * self.manual_rotate_speed
    right_motor_vel = vel * 10 - self.manual_rotate * self.manual_rotate_speed

    print(f"pitch: {self.pitch_gain}, pos: {self.pos_gain}, vel: {vel}")
    sim.setJointTargetVelocity(self.left_motor, left_motor_vel)
    sim.setJointTargetVelocity(self.right_motor, right_motor_vel)

    # self.prev_vel = vel_error
    self.prev_p = pitch_error
    self.prev_pos = pos_error
        # self.tame = time

def sysCall_sensing():
    # put your sensing code here
    # This function will be executed at each simulation time step
    
    ####### ADD YOUR CODE HERE ######
    # Hint: Take feedback here & do the error calculation
    
    #################################
    self.pos = sim.getObjectPosition(self.body, -1)[1]
    
    # Initialize errors and PID variables
    eulerAngles = sim.getObjectOrientation(self.body)
    pitch, yaw, self.pitch = sim.alphaBetaGammaToYawPitchRoll(eulerAngles[0], eulerAngles[1], eulerAngles[2])
    print(pitch)
    print(f"pitch: {self.pitch}")

    message, data, data2 = sim.getSimulatorMessage()
    if message == sim.message_keypress:
        if data[0] == 2007:  # forward up arrow
            self.target_pos += 0.01
            self.manual_rotate = 0
            self.desired_vel = 1
        elif data[0] == 2008:  # backward down arrow
            self.target_pos -= 0.01
            self.desired_vel = -1
            self.manual_rotate = 0
        elif (data[0] == 2009):  # left arrow key (rotate left)
            self.manual_rotate = 1  # Positive for left rotation
            self.desired_vel = 0
        elif (data[0] == 2010):  # right arrow key (rotate right)
            self.manual_rotate = -1  # Negative for right rotation
            self.desired_vel = 0
        else:
            self.manual_rotate = 0

            self.desired_vel = 0
    else:
        # pass
        self.manual_rotate = 0
        self.desired_vel = 0


    # Calculate errors
    

    # PID control
    # self.pitch_gain, self.p_integral = PID(self.pi_kp, self.pi_ki, self.pi_kd, pitch_error, self.prev_p, self.p_integral)
    # self.pos_gain, self.pos_integral = PID(self.p_kp, self.p_ki, self.p_kd, pos_error, self.prev_pos, self.pos_integral)
    # vel = self.pitch_gain - self.pos_gain
    # print(f"pitch: {self.pitch_gain}, pos: {self.pos_gain}, vel: {vel}")
    # sim.setJointTargetVelocity(self.left_motor, vel * 10)
    # sim.setJointTargetVelocity(self.right_motor, vel * 10)



    
# Convert radians to degrees)

def PID(kp, ki, kd, err, prev_err, integral):
    derivative = (err - prev_err)/0.5
    integral += err*0.5
    response = kp * err + ki * integral + kd * derivative
    return response, integral

def sysCall_cleanup():
    # do some clean-up here
    # This function will be executed when the simulation ends
    
    ####### ADD YOUR CODE HERE ######
    # Any cleanup (if required) to take the scene back to it's original state after simulation
    # It helps in case simulation fails in an unwanted state.
    #################################
    pass

# See the user manual or the available code snippets for additional callback functions and details