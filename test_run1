import math
import time
def sysCall_init():
    sim = require('sim')

    # do some initialization here
    # This function will be executed once when the simulation starts

    
    # Instead of using globals, you can do e.g.:
    # self.myVariable = 21000000
    
    ######## ADD YOUR CODE HERE #######
    # Hint: Initialize the scene objects which you will require
    #       Initialize algorithm related variables here
    
    
    ##################################
    self.left_motor = sim.getObject('/left_joint')
    self.right_motor = sim.getObject('/right_joint')
    self.body = sim.getObject('/body')
    
    self.graph = sim.getObject('/Graph')
    self.time = sim.addGraphStream(self.graph, 'time', 'm', 1)
    self.error = sim.addGraphStream(self.graph, 'Error', 'm', 1)
    sim.addGraphCurve(self.graph, 'error/time', 2, [self.time, self.error], [0, 0])

    self.graph_pos = sim.getObject('/Graph_pos')
    self.time1 = sim.addGraphStream(self.graph_pos, 'time', 'm', 1)
    self.pos_g = sim.addGraphStream(self.graph_pos, 'pgain', 'm', 1)
    sim.addGraphCurve(self.graph_pos, 'pos/posi', 2, [self.time1, self.pos_g], [0, 0])

    self.graph_ori = sim.getObject('/Graph_ori')
    self.time2 = sim.addGraphStream(self.graph_ori, 'time', 'm', 1)
    self.ori_g = sim.addGraphStream(self.graph_ori, 'pgain', 'm', 1)
    sim.addGraphCurve(self.graph_ori, 'pos/posi', 2, [self.time2, self.ori_g], [0, 0])

    self.graph_orin = sim.getObject('/Graph_orin')
    self.time3 = sim.addGraphStream(self.graph_orin, 'time', 'm', 1)
    self.orin = sim.addGraphStream(self.graph_orin, 'ori', 'm', 1)
    sim.addGraphCurve(self.graph_orin, 'pos/posi', 2, [self.time3, self.orin], [0, 0])
    # PID Controller gains for orientation and position
    self.ori_kp = 50      # Proportional gain for orientation
    self.ori_ki = 295       # Integral gain for orientation
    self.ori_kd = 0.5       # Derivative gain for orientation
    self.pos_kp = 100      # Proportional gain for position
    self.pos_ki = 0.1      # Integral gain for position
    self.pos_kd = 0.2       # Derivative gain for position
    
    self.i = 0
    
    # Desired orientation and position
    self.erect = 0
    self.ini_pos = sim.getObjectPosition(self.body, -1)[1]
    
    # Initialize errors and PID variables
    orientation = sim.getObjectOrientation(self.body)

# Convert radians to degrees
    self.ori = orientation[0] * (180 / math.pi)
    
    self.prev_pos = 0
    self.posi = sim.getObjectPosition(self.body, -1)[1]
    self.prev_ori_err = 0   # Previous orientation error for PID
    self.prev_pos_err = 0   # Previous position error for PID
    self.ori_int = 0        # Integral term for orientation PID
    self.pos_int = 0        # Integral term for position PID
    self.dt = sim.getSimulationTimeStep()  # Time step of the simulation
    torque = 2
    sim.setJointMaxForce(self.left_motor, torque)
    sim.setJointMaxForce(self.right_motor, torque)
    print("Done initializing")
    
def sysCall_sensing():
    # put your sensing code here
    # This function will be executed at each simulation time step
    
    ####### ADD YOUR CODE HERE ######
    # Hint: Take feedback here & do the error calculation
    
    #################################
    orientation = sim.getObjectOrientation(self.body)

# Convert radians to degrees
    self.ori = orientation[0] * (180 / math.pi)
    
    self.posi = sim.getObjectPosition(self.body, -1)[1]
    

    
def sysCall_actuation():
    # put your actuation code here
    # This function will be executed at each simulation time step

    ####### ADD YOUR CODE HERE ######
    # Hint: Use the error feedback and apply control algorithm here
    #       Provide the resulting actuation as input to the actuator joint
    
    # Example psuedo code:
    #   x1 = error_state_1; # Error in states w.r.t desired setpoint
    #   x2 = error_state_2;
    #   x3 = error_state_3;
    #   x4 = error_state_4;
    #   k = [gain_1 , gain_1, gain_3, gain_4];      # These gains will be generated by control algorithm. For ex: LQR, PID, etc.
    #   U = -k[1]*x1 +k[2]*x2 -k[3]*x3 +k[4]*x4;    # +/- Sign convention may differ according to implementation
    #   Set_joint_actuation(U);                     # Provide this calculated input to system's actuator

    #################################
    ori_error = self.erect - self.ori
    pos_error = self.prev_pos - self.posi
    
    # Get PID gains for both orientation and position control
    print(f"Orientation: {self.ori}, wheel_pos: {pos_error}, error: {ori_error}, ori_gain")
    self.ori_gain, self.ori_int = PID(self.ori_kp, self.ori_ki, self.ori_kd, ori_error, self.prev_ori_err, self.ori_int)
    
    # print("sfasggsdfu")
    self.pos_gain, self.pos_int = PID(self.pos_kp, self.pos_ki, self.pos_kd, pos_error, self.prev_pos_err, self.pos_int)
    vel = self.ori_gain/6.5 + self.pos_gain
    print(f", vel: {vel},")
    # 
    # if self.ori < 0 and self.pos
    if vel >= 10:
        vel = 10
    elif vel <= -10:
        vel = -10
    sim.setJointTargetVelocity(self.left_motor, vel)
    sim.setJointTargetVelocity(self.right_motor, vel)
    
    sim.setGraphStreamValue(self.graph, self.time, sim.getSimulationTime())
    sim.setGraphStreamValue(self.graph, self.error, vel)

    sim.setGraphStreamValue(self.graph_pos, self.time1, sim.getSimulationTime())
    sim.setGraphStreamValue(self.graph_pos, self.pos_g, self.pos_gain)

    sim.setGraphStreamValue(self.graph_ori, self.time2, sim.getSimulationTime())
    sim.setGraphStreamValue(self.graph_ori, self.ori_g, self.ori_gain)
    
    sim.setGraphStreamValue(self.graph_orin, self.time3, sim.getSimulationTime())
    sim.setGraphStreamValue(self.graph_orin, self.orin, self.ori)

    # Update previous errors
    self.prev_ori_err = ori_error
    self.prev_pos_err = pos_error
    self.prev_pos = self.posi/2
    self.i += 1
    # Combine gains for back-and-forth motion
    # Use orientation control to maintain balance
    
    

    
  # Gyroscope providing angular velocity

def PID(kp, ki, kd, err, prev_error, integral):
    # Standard PID controller implementation
    derivative = (err - prev_error) / self.dt
    integral += err * self.dt
    output = kp * err + ki * integral + kd * derivative
    print(f"output: {output}, integral: {integral}, derivative: {derivative}")
    return output, integral
    
def sysCall_cleanup():
    # do some clean-up here
    # This function will be executed when the simulation ends
    
    ####### ADD YOUR CODE HERE ######
    # Any cleanup (if required) to take the scene back to it's original state after simulation
    # It helps in case simulation fails in an unwanted state.
    #################################
    pass

# See the user manual or the available code snippets for additional callback functions and details

